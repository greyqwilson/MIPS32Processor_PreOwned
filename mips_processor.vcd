$date
	Mon Nov 28 14:38:35 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module MIPS_Test $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module processor $end
$var wire 1 ! clk $end
$var wire 1 # ctrl_reg_dest $end
$var wire 1 " reset $end
$var wire 5 $ writeRegNbr [4:0] $end
$var wire 1 % zero_out $end
$var wire 32 & sign_ext_out [31:0] $end
$var wire 32 ' shifted_address [31:0] $end
$var wire 32 ( reg2_out [31:0] $end
$var wire 32 ) reg1_out [31:0] $end
$var wire 32 * mem_to_reg [31:0] $end
$var wire 32 + mem_out [31:0] $end
$var wire 32 , jump_branch_add_out [31:0] $end
$var wire 32 - instruction [31:0] $end
$var wire 1 . ctrl_reg_write $end
$var wire 1 / ctrl_mem_write $end
$var wire 1 0 ctrl_mem_to_reg $end
$var wire 1 1 ctrl_mem_read $end
$var wire 1 2 ctrl_branch $end
$var wire 1 3 ctrl_alu_src $end
$var wire 2 4 ctrl_alu_op [1:0] $end
$var wire 32 5 alu_src_out [31:0] $end
$var wire 32 6 alu_result [31:0] $end
$var wire 32 7 address_plus_4 [31:0] $end
$var wire 32 8 PC_out [31:0] $end
$var wire 32 9 PC_in [31:0] $end
$scope module ALU $end
$var wire 32 : B [31:0] $end
$var wire 6 ; func_field [5:0] $end
$var wire 6 < opcode [5:0] $end
$var wire 1 % zero $end
$var wire 32 = result [31:0] $end
$var wire 3 > alu_control [2:0] $end
$var wire 32 ? A [31:0] $end
$scope module alucore_inst $end
$var wire 32 @ B [31:0] $end
$var wire 1 % zero $end
$var wire 3 A alu_control [2:0] $end
$var wire 32 B A [31:0] $end
$var reg 32 C result [31:0] $end
$upscope $end
$scope module aluctrl_inst $end
$var wire 6 D func_field [5:0] $end
$var wire 6 E opcode [5:0] $end
$var reg 3 F alu_control [2:0] $end
$var reg 3 G func_code [2:0] $end
$upscope $end
$upscope $end
$scope module DMem $end
$var wire 32 H address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 / write_enable $end
$var wire 32 I write_data [31:0] $end
$var wire 32 J read_data [31:0] $end
$var wire 1 1 mem_read $end
$upscope $end
$scope module IMem $end
$var wire 32 K instruction [31:0] $end
$var wire 32 L address [31:0] $end
$upscope $end
$scope module PC $end
$var wire 32 M address_in [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 N address_out [31:0] $end
$upscope $end
$scope module SEUnit $end
$var wire 16 O bits_in [15:0] $end
$var wire 32 P bits_out [31:0] $end
$upscope $end
$scope module SLUnit $end
$var wire 32 Q address_in [31:0] $end
$var wire 32 R address_out [31:0] $end
$upscope $end
$scope module address_increment_adder $end
$var wire 32 S a [31:0] $end
$var wire 32 T b [31:0] $end
$var wire 32 U sum [31:0] $end
$upscope $end
$scope module control $end
$var wire 1 3 alu_src $end
$var wire 6 V opcode [5:0] $end
$var wire 1 # reg_dest $end
$var wire 1 . reg_write $end
$var wire 1 / mem_write $end
$var wire 1 0 mem_to_reg $end
$var wire 1 1 mem_read $end
$var wire 1 2 branch $end
$var wire 2 W alu_op [1:0] $end
$upscope $end
$scope module jump_offset_adder $end
$var wire 32 X a [31:0] $end
$var wire 32 Y b [31:0] $end
$var wire 32 Z sum [31:0] $end
$upscope $end
$scope module regFile $end
$var wire 1 ! clk $end
$var wire 5 [ reg1_address [4:0] $end
$var wire 32 \ reg1_read [31:0] $end
$var wire 5 ] reg2_address [4:0] $end
$var wire 32 ^ reg2_read [31:0] $end
$var wire 1 " reset $end
$var wire 32 _ write_data [31:0] $end
$var wire 1 . write_enable $end
$var wire 5 ` write_register [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1010 `
b110011 _
b100010 ^
b1010 ]
b10001 \
b1001 [
b10110000010000100 Z
b10110000010000000 Y
b100 X
b10 W
b0 V
b100 U
b0 T
b100 S
b10110000010000000 R
b101100000100000 Q
b101100000100000 P
b101100000100000 O
b0 N
b100 M
b0 L
b1001010100101100000100000 K
b0xxxxxxxx J
b100010 I
b110011 H
b0 G
b0 F
b0 E
b100000 D
b110011 C
b10001 B
b0 A
b100010 @
b10001 ?
b0 >
b110011 =
b0 <
b100000 ;
b100010 :
b100 9
b0 8
b100 7
b110011 6
b100010 5
b10 4
03
02
01
00
0/
1.
b1001010100101100000100000 -
b10110000010000100 ,
b0xxxxxxxx +
b110011 *
b10001 )
b100010 (
b10110000010000000 '
b101100000100000 &
0%
b1010 $
0#
0"
1!
$end
#5
0!
#10
1!
#15
0!
#20
1!
#25
0!
#30
b10101 6
b10101 =
b10101 C
b10101 H
b10000 '
b10000 R
b10000 Y
b0xxxxxxxx *
b0xxxxxxxx _
13
b100 5
b100 :
b100 @
b1000 9
b1000 M
b100 ;
b100 D
b100 &
b100 P
b100 Q
b100 O
11
10
b0 4
b0 W
b100011 V
b100011 <
b100011 E
b110011 (
b110011 I
b110011 ^
b11000 ,
b11000 Z
b1000 7
b1000 U
b1000 X
b10001101001010100000000000000100 -
b10001101001010100000000000000100 K
b100 8
b100 L
b100 N
b100 T
1!
1"
#35
0!
#40
1%
b0 +
b0 J
b0 6
b0 =
b0 C
b0 H
b100 '
b100 R
b100 Y
b10001 5
b10001 :
b10001 @
b0 *
b0 _
03
0.
b1 >
b1 A
b1 F
b10000 9
b10000 M
b1 ;
b1 D
b1 &
b1 P
b1 Q
b1 O
b1001 $
b1001 `
b1001 ]
12
01
00
b1 4
b1 W
b100 V
b100 <
b100 E
b10000 ,
b10000 Z
b1100 7
b1100 U
b1100 X
b10001001010010000000000000001 -
b10001001010010000000000000001 K
b1000 8
b1000 L
b1000 N
b1000 T
b10001 (
b10001 I
b10001 ^
1!
#45
0!
#50
bx *
bx _
b11000000010010100 '
b11000000010010100 R
b11000000010010100 Y
bx 5
bx :
bx @
x%
b0xxxxxxxx +
b0xxxxxxxx J
bx 6
bx =
bx C
bx H
1.
b11 >
b11 A
b11 F
b11 G
b10100 9
b10100 M
b100101 ;
b100101 D
b110000000100101 &
b110000000100101 P
b110000000100101 Q
b110000000100101 O
b1011 $
b1011 `
bx (
bx I
bx ^
b1011 ]
b0xxxxxxxx )
b0xxxxxxxx ?
b0xxxxxxxx B
b0xxxxxxxx \
b1010 [
02
b10 4
b10 W
b0 V
b0 <
b0 E
b11000000010101000 ,
b11000000010101000 Z
b10100 7
b10100 U
b10100 X
b1010010110110000000100101 -
b1010010110110000000100101 K
b10000 8
b10000 L
b10000 N
b10000 T
1!
#55
0!
#60
b10101 *
b10101 _
0%
b10101 6
b10101 =
b10101 C
b10101 H
b10000 '
b10000 R
b10000 Y
b100 5
b100 :
b100 @
13
0.
b0 >
b0 A
b0 F
b0 G
b11000 9
b11000 M
b100 ;
b100 D
b100 &
b100 P
b100 Q
b100 O
b1010 $
b1010 `
b0xxxxxxxx (
b0xxxxxxxx I
b0xxxxxxxx ^
b1010 ]
b10001 )
b10001 ?
b10001 B
b10001 \
b1001 [
b0 4
b0 W
1/
b101011 V
b101011 <
b101011 E
b101000 ,
b101000 Z
b11000 7
b11000 U
b11000 X
b10101101001010100000000000000100 -
b10101101001010100000000000000100 K
b10100 8
b10100 L
b10100 N
b10100 T
1!
#65
0!
#70
bx00 '
bx00 R
bx00 Y
bx 5
bx :
bx @
bx *
bx _
x3
x.
x%
bx 6
bx =
bx C
bx H
bx 9
bx M
bx ;
bx D
bx &
bx P
bx Q
bx O
bx $
bx `
bx (
bx I
bx ^
bx ]
x2
x1
x0
bx 4
bx W
x/
bx V
bx <
bx E
bx )
bx ?
bx B
bx \
bx [
bx ,
bx Z
b11100 7
b11100 U
b11100 X
bx -
bx K
b11000 8
b11000 L
b11000 N
b11000 T
1!
#75
0!
#80
bx 7
bx U
bx X
bx 8
bx L
bx N
bx T
1!
#85
0!
#90
1!
#95
0!
#100
1!
